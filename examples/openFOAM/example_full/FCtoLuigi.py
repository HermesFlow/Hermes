

import shutil
import os
import luigi
import json 
import sys

sys.path.insert(1, "/home/noga/Noga/FreeCad/github/Hermes/master/Hermes")
from hermes.engines.luigi.taskUtils import utils as hermesutils

class RASProperties_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {}, 'nodeList': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'nodes': {'SnappyHexMesh': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}}, 'ControlDict': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}}, 'FvSchemes': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}}, 'FvSolution': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}}, 'TransportProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}}, 'RASProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'Execution': {'type': 'generalExecuters.parameter', 'input_parameters': {}}, 'requires': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'GUI': {'TypeFC': {}, 'Properties': {}, 'WebGui': {}}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/RASProperties_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['formData']   = {}
        params['files']      = {}
        params['Schema']     = {}
        params['uiSchema']   = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}

        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/openFOAM/example_full'
                    
        from hermes.Resources.executers.jinjaExecuters import jinjaExecuter  
        output = jinjaExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class ControlDict_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {}, 'nodeList': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'nodes': {'SnappyHexMesh': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}}, 'ControlDict': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}}, 'FvSchemes': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}}, 'FvSolution': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}}, 'TransportProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}}, 'RASProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'Execution': {'type': 'generalExecuters.parameter', 'input_parameters': {}}, 'requires': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'GUI': {'TypeFC': {}, 'Properties': {}, 'WebGui': {}}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/ControlDict_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['formData']   = {}
        params['files']      = {}
        params['Schema']     = {}
        params['uiSchema']   = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}

        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/openFOAM/example_full'
                    
        from hermes.Resources.executers.jinjaExecuters import jinjaExecuter  
        output = jinjaExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class SnappyHexMesh_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {}, 'nodeList': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'nodes': {'SnappyHexMesh': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}}, 'ControlDict': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}}, 'FvSchemes': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}}, 'FvSolution': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}}, 'TransportProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}}, 'RASProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'Execution': {'type': 'generalExecuters.parameter', 'input_parameters': {}}, 'requires': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'GUI': {'TypeFC': {}, 'Properties': {}, 'WebGui': {}}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/SnappyHexMesh_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['formData']   = {}
        params['files']      = {}
        params['Schema']     = {}
        params['uiSchema']   = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}

        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/openFOAM/example_full'
                    
        from hermes.Resources.executers.jinjaExecuters import jinjaExecuter  
        output = jinjaExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class FvSchemes_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {}, 'nodeList': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'nodes': {'SnappyHexMesh': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}}, 'ControlDict': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}}, 'FvSchemes': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}}, 'FvSolution': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}}, 'TransportProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}}, 'RASProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'Execution': {'type': 'generalExecuters.parameter', 'input_parameters': {}}, 'requires': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'GUI': {'TypeFC': {}, 'Properties': {}, 'WebGui': {}}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/FvSchemes_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['formData']   = {}
        params['files']      = {}
        params['Schema']     = {}
        params['uiSchema']   = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}

        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/openFOAM/example_full'
                    
        from hermes.Resources.executers.jinjaExecuters import jinjaExecuter  
        output = jinjaExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class TransportProperties_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {}, 'nodeList': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'nodes': {'SnappyHexMesh': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}}, 'ControlDict': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}}, 'FvSchemes': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}}, 'FvSolution': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}}, 'TransportProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}}, 'RASProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'Execution': {'type': 'generalExecuters.parameter', 'input_parameters': {}}, 'requires': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'GUI': {'TypeFC': {}, 'Properties': {}, 'WebGui': {}}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/TransportProperties_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['formData']   = {}
        params['files']      = {}
        params['Schema']     = {}
        params['uiSchema']   = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}

        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/openFOAM/example_full'
                    
        from hermes.Resources.executers.jinjaExecuters import jinjaExecuter  
        output = jinjaExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class FvSolution_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {}, 'nodeList': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'nodes': {'SnappyHexMesh': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}}, 'ControlDict': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}}, 'FvSchemes': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}}, 'FvSolution': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}}, 'TransportProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}}, 'RASProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'Execution': {'type': 'generalExecuters.parameter', 'input_parameters': {}}, 'requires': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'GUI': {'TypeFC': {}, 'Properties': {}, 'WebGui': {}}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/FvSolution_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['formData']   = {}
        params['files']      = {}
        params['Schema']     = {}
        params['uiSchema']   = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}

        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/openFOAM/example_full'
                    
        from hermes.Resources.executers.jinjaExecuters import jinjaExecuter  
        output = jinjaExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class finalnode_xx_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {}, 'nodeList': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'nodes': {'SnappyHexMesh': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/SnappyHexMeshDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Surface', 'properties': {'triSurfaceMesh': {'type': 'object', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}, 'featuresTSM': {'type': 'object', 'title': 'features', 'description': 'features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}, 'refinementSurfacesTSM': {'type': 'object', 'title': 'refinementSurfaces', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}}}, 'layersTSM': {'type': 'object', 'title': 'layers', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}}, {'type': 'object', 'title': 'Region', 'properties': {'searchableObject': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'Box', 'properties': {'nameBOX': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this Region'}, 'propertiesBOX': {'type': 'object', 'title': 'properties', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, 'refinementRegionsBox': {'type': 'object', 'title': 'refinementRegions', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}, {'type': 'object', 'title': 'Cone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'Cylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'Disk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'ExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'Plane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'Plate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'RotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'Sphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}]}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'triSurfaceMesh': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings', 'featuresTSM': {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}, 'layersTSM': {'nSurfaceLayers': 1}}}, {'triSurfaceMesh': {'layersTSM': {}, 'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo', 'featuresTSM': {'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, 'refinementSurfacesTSM': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}}, {'searchableObject': {'nameBOX': 'refinementBox', 'propertiesBOX': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'refinementRegionsBox': {'mode': 'inside', 'levels': '((1E15 1))'}}}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}}, 'ControlDict': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/ControlDict'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFoam', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}}, 'FvSchemes': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSchemes'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'gradU': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'gradK': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'gradEpsilon': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'divPhiU': {'type': 'string', 'title': 'div(phi,U)'}, 'divPhiK': {'type': 'string', 'title': 'div(phi,k)'}, 'divPhiEpsilon': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'divPhiE': {'type': 'string', 'title': 'div(phi,e)'}, 'divPhiOmega': {'type': 'string', 'title': 'div(phi,omega)'}, 'moreDivSchemesProperties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'gradU': 'cellLimited Gauss linear 1', 'gradK': 'cellLimited Gauss linear 1', 'gradEpsilon': 'cellLimited Gauss linear 1'}, 'divSchemes': {'moreDivSchemesProperties': {'divNuEff': 'Gauss linear'}, 'default': 'none', 'divPhiU': 'bounded Gauss upwind', 'divPhiK': 'bounded Gauss upwind', 'divPhiEpsilon': 'bounded Gauss upwind', 'divPhiOmega': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}}, 'FvSolution': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/FvSolution'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}}, 'TransportProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TransportProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}}, 'RASProperties': {'Execution': {'type': 'jinjaExecuters.jinja', 'input_parameters': {'values': '{WebGui.formData}', 'template': 'openFOAM/simpleFOAM/TurbulenceProperties'}}, 'GUI': {'Type': 'WebGuiNode', 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModelCoeffs': {}, 'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'Execution': {'type': 'generalExecuters.parameter', 'input_parameters': {}}, 'requires': ['SnappyHexMesh', 'ControlDict', 'FvSchemes', 'FvSolution', 'TransportProperties', 'RASProperties'], 'GUI': {'TypeFC': {}, 'Properties': {}, 'WebGui': {}}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/finalnode_xx_0.json")

    def requires(self):
        return dict(
                       RASProperties=RASProperties_0(),
                       ControlDict=ControlDict_0(),
                       SnappyHexMesh=SnappyHexMesh_0(),
                       FvSchemes=FvSchemes_0(),
                       TransportProperties=TransportProperties_0(),
                       FvSolution=FvSolution_0()
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['formData']   = {}
        params['files']      = {}
        params['Schema']     = {}
        params['uiSchema']   = {}
        params['Properties'] = {}
        params['WebGui']     = {}

        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/openFOAM/example_full'
                    
        from hermes.Resources.executers.generalExecuters import parameterExecuter  
        output = parameterExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)
