

import shutil
import os
import luigi
import json 
import sys

sys.path.insert(1, "/home/noga/Noga/FreeCad/github/Hermes/master/Hermes")
from hermes.engines.luigi.taskUtils import utils as hermesutils

class SnappyHexMesh_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/SnappyHexMesh_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'formData': '{WebGui.formData}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import snappyHexMesh  
        output =  snappyHexMesh(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class RASProperties_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/RASProperties_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'formData': '{WebGui.formData}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import RASProperties  
        output =  RASProperties(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class fvSolution_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/fvSolution_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'formData': '{WebGui.formData}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import fvSolution  
        output =  fvSolution(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class RunPythonScript_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/RunPythonScript_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}
        params['WebGui']     = {}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import RunPythonScript  
        output =  RunPythonScript(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class CopyDirectory_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/CopyDirectory_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}
        params['WebGui']     = {}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.fileSystemExecuter import copyDirectory  
        output =  copyDirectory(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class transportProperties_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/transportProperties_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'formData': '{WebGui.formData}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import transportProperties  
        output =  transportProperties(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class RunOsCommand_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/RunOsCommand_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}
        params['WebGui']     = {}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.fileSystemExecuter import RunOsCommand  
        output =  RunOsCommand(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class BC_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/BC_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}
        params['WebGui']     = {}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import pythonExecuter  
        output =  pythonExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class fvSchemes_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/fvSchemes_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'formData': '{WebGui.formData}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import fvSchemes  
        output =  fvSchemes(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class ControlDict_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/ControlDict_0.json")

    def requires(self):
        return dict(
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {'formData': '{WebGui.formData}'}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {}
        params['WebGui']     = {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.pythonExecuter import controlDict  
        output =  controlDict(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)

class finalnode_xx_0(luigi.Task,hermesutils):

    _taskJSON = None
    _workflowJSON = None 
    
    @property 
    def workflowJSON(self):
        return self._workflowJSON
        
    @property 
    def taskJSON(self):
        return self._taskJSON
    
    def __init__(self,*args,**kwargs): 
        super().__init__(*args,**kwargs)
        self._taskJSON ={}
        
        self._workflowJSON = {'workflow': {'root': None, 'Templates': {'importJsonfromfile': {'path': '../../hermes/Resources/nodeTemplates/templates.json'}}, 'nodeList': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'nodes': {'CopyDirectory': {'typeExecution': 'copyDirectory', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Source': '{Properties.Source.current_val}', 'Target': '{Properties.Target.current_val}'}, 'Properties': {'Source': {'prop': 'Source', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The source directory', 'current_val': ''}, 'Target': {'prop': 'Target', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'Parameters', 'tooltip': 'The target directory', 'current_val': ''}}, 'WebGui': {}}, 'RunPythonScript': {'typeExecution': 'RunPythonScript', 'TypeFC': 'WebGuiNode', 'input_parameters': {'ModulePath': 'Properties.ModulePath.current_val', 'MethodName': 'Properties.MethodName.current_val', 'Parameters': 'Properties.Parameters.current_val'}, 'Properties': {'ModulePath': {'prop': 'ModulePath', 'init_val': '', 'type': 'App::PropertyPath', 'Heading': 'PythonNodule', 'tooltip': 'The path to the python module directory', 'current_val': ''}, 'MethodName': {'prop': 'MethodName', 'init_val': '', 'type': 'App::PropertyString', 'Heading': 'PythonNodule', 'tooltip': 'The python module name', 'current_val': ''}, 'Parameters': {'prop': 'Parameters', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'PythonNodule', 'tooltip': 'The python module input parameters', 'current_val': []}}, 'WebGui': {}}, 'RunOsCommand': {'typeExecution': 'RunOsCommand', 'TypeFC': 'WebGuiNode', 'input_parameters': {'Method': '{Properties.ChooseMethod.current_val}', 'Commands': '{Properties.Commands.current_val}', 'batchFile': '{Properties.batchFile.current_val}'}, 'Properties': {'ChooseMethod': {'prop': 'ChooseMethod', 'init_val': ['Commands list', 'batchFile'], 'type': 'App::PropertyEnumeration', 'Heading': 'Parameters', 'tooltip': 'True-commands, False-file', 'current_val': 'Commands list'}, 'Commands': {'prop': 'Commands', 'init_val': [], 'type': 'App::PropertyStringList', 'Heading': 'Parameters', 'tooltip': 'The OS commands to execute', 'current_val': ["echo 'Here is an example of a shell script'", "echo '1a. File listing'", 'ls', "echo ''"]}, 'batchFile': {'prop': 'batchFile', 'init_val': 'Text', 'type': 'App::PropertyFile', 'Heading': 'Parameters', 'tooltip': 'File containing all the OS commands to execute', 'current_val': ''}}, 'WebGui': {}}, 'BC': {'typeExecution': 'executerPython', 'TypeFC': 'BCFactory', 'input_parameters': {}, 'Properties': {'Property1': {'prop': 'IntegerProperty', 'init_val': 10, 'type': 'App::PropertyInteger', 'Heading': 'PropInteger', 'tooltip': 'IntegerProperty', 'current_val': 10}}, 'BCTypes': {'TypeList': ['wall', 'sym'], 'TypeProperties': {'wall': {'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 m/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 m/s'}}}, 'sym': {'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '10 Pa'}}}}}, 'BCList': {'BC1': {'Name': 'wall', 'Type': 'wall', 'Properties': {'Property01': {'prop': 'Ux', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in x direction ', 'current_val': '0 mm/s'}, 'Property02': {'prop': 'Uy', 'init_val': '0 m/s', 'type': 'App::PropertySpeed', 'Heading': 'Velocity', 'tooltip': 'Velocity in y direction', 'current_val': '0 mm/s'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face1', 'Face2']}}}, 'BC2': {'Name': 'symmetry', 'Type': 'sym', 'Properties': {'Property01': {'prop': 'P0', 'init_val': '10 Pa', 'type': 'App::PropertyPressure', 'Heading': 'Pressure', 'tooltip': 'Total Pressure ', 'current_val': '0.01 kg/(mm*s^2)'}}, 'faceList': {'Part1': {'Name': 'Cube', 'Path': '/', 'faces': ['Face3', 'Face4']}}}}}, 'SnappyHexMesh': {'typeExecution': 'snappyHexMesh', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'castellatedMesh': {'type': 'boolean', 'title': 'castellatedMesh', 'description': 'To switch on creation of the castellated mesh'}, 'snap': {'type': 'boolean', 'title': 'snap', 'description': 'To switch on surface snapping stage'}, 'addLayers': {'type': 'boolean', 'title': 'addLayers', 'description': 'To switch on surface layer insertion'}, 'mergeTolerance': {'title': 'mergeTolerance', 'type': 'number', 'default': 1e-06, 'description': 'merge tolerance as fraction of bounding box of initial mesh'}, 'geometry': {'type': 'array', 'title': 'geometry', 'items': {'type': 'object', 'properties': {'nameSO': {'type': 'string', 'title': 'name', 'description': 'Define region name'}, 'geometry objects': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'triSurfaceMesh', 'properties': {'typeTSM': {'type': 'string', 'title': 'type'}, 'regionsTSM': {'type': 'array', 'title': 'regions', 'items': {'type': 'array', 'title': 'secondSolid', 'items': {'type': 'string', 'title': 'name'}}, 'description': 'Per region the patch name'}, 'toleranceTSM': {'type': 'number', 'title': 'tolerance', 'description': 'Tolerance to use for intersection tests'}, 'scaleTSM': {'type': 'number', 'title': 'scale', 'description': 'Scale factor to apply to the points'}, 'nameTSM': {'type': 'string', 'title': 'name', 'description': 'Name to use to refer to this surface'}}}, {'type': 'object', 'title': 'searchableBox', 'properties': {'typeBox': {'type': 'string', 'title': 'type'}, 'minBox': {'type': 'string', 'title': 'min', 'format': 'vector', 'description': 'Box minimum point'}, 'maxBox': {'type': 'string', 'title': 'max', 'format': 'vector', 'description': 'Box maximum point'}}}, {'type': 'object', 'title': 'searchableCone', 'properties': {'typeCone': {'type': 'string', 'title': 'type'}, 'point1Cone': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius1Cone': {'title': 'radius1', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius1Cone': {'title': 'innerRadius1', 'type': 'number', 'description': 'Inner radius at the start'}, 'point2Cone': {'type': 'string', 'title': 'point2', 'format': 'vector', 'description': 'Axis point at the start'}, 'radius2Cone': {'title': 'radius2', 'type': 'number', 'description': 'Outer radius at the start'}, 'innerRadius2Cone': {'title': 'innerRadius2', 'type': 'number', 'description': 'Inner radius at the start'}}}, {'type': 'object', 'title': 'searchableCylinder', 'properties': {'typeCylinder': {'type': 'string', 'title': 'type'}, 'point1Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the start'}, 'point2Cylinder': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Axis point at the end'}, 'radiusCylinder': {'title': 'radius', 'type': 'number', 'description': 'Cylinder radius'}}}, {'type': 'object', 'title': 'searchableDisk', 'properties': {'typeDisk': {'type': 'string', 'title': 'type'}, 'originDisk': {'type': 'string', 'title': 'origin', 'format': 'vector', 'description': 'Disk origin'}, 'normalDisk': {'type': 'string', 'title': 'normal', 'format': 'vector', 'description': 'Normal direction'}, 'radiusDisk': {'title': 'radius', 'type': 'number', 'description': 'Disk radius'}}}, {'type': 'object', 'title': 'searchableExtrudedCircle', 'properties': {'typeExtrudedCircle': {'type': 'string', 'title': 'type', 'description': 'A shape defined by inflating a segmented line into a tube with constant radius. Note that only near queries are implemented, i.e. no testing for intersections or inside/outside.'}, 'fileExtrudedCircle': {'type': 'string', 'title': 'file Name', 'description': 'example: curve2.vtk '}, 'radiusExtrudedCircle': {'title': 'radius', 'type': 'number', 'description': 'Constant radius'}}}, {'type': 'object', 'title': 'searchablePlane', 'properties': {'typePlane': {'type': 'string', 'title': 'type'}, 'planeType': {'type': 'object', 'anyOf': [{'title': 'pointAndNormal', 'description': 'Plane defined by point and a normal vector', 'properties': {'basePointPAN': {'type': 'string', 'title': 'basePoint', 'format': 'vector'}, 'normalPAN': {'type': 'string', 'title': 'normal', 'format': 'vector'}}}, {'title': 'embeddedPoints', 'description': 'Plane defined by 3 points on the plane', 'properties': {'point1EP': {'type': 'string', 'title': 'point1', 'format': 'vector'}, 'point2EP': {'type': 'string', 'title': 'point2', 'format': 'vector'}, 'point3EP': {'type': 'string', 'title': 'point3', 'format': 'vector'}}}, {'title': 'planeEquation', 'description': 'Plane defined by plane equation:', 'properties': {'aPE': {'type': 'integer', 'title': 'a'}, 'bPE': {'type': 'integer', 'title': 'b'}, 'cPE': {'type': 'integer', 'title': 'c'}, 'dPE': {'type': 'integer', 'title': 'd'}}}]}}}, {'type': 'object', 'title': 'searchablePlate', 'properties': {'typePlate': {'type': 'string', 'title': 'type', 'description': 'A finite plate aligned with co-ordinate system. Plate could be used e.g. to create a baffle or measuring plane'}, 'originPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of plate'}, 'spanPlate': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Span in each direction - User must specify span in two directions, the third must be zero.'}}}, {'type': 'object', 'title': 'searchableRotatedBox', 'properties': {'typeRotatedBox': {'type': 'string', 'title': 'type'}, 'spanRB': {'type': 'string', 'title': 'span'}, 'originRB': {'type': 'string', 'title': 'origin'}, 'ei-vectors': {'type': 'object', 'description': 'The rotation is defined by a combination of vectors (e1/e2),(e2/e3) or (e3/e1)', 'anyOf': [{'title': 'Option1-e1,e2', 'properties': {'e1OP1': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e2OP1': {'type': 'string', 'title': 'e2', 'format': 'vector'}}}, {'title': 'Option2-e1,e3', 'properties': {'e1OP2': {'type': 'string', 'title': 'e1', 'format': 'vector'}, 'e3OP2': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}, {'title': 'Option3-e2,e3', 'properties': {'e2OP3': {'type': 'string', 'title': 'e2', 'format': 'vector'}, 'e3OP3': {'type': 'string', 'title': 'e3', 'format': 'vector'}}}]}}}, {'type': 'object', 'title': 'searchableSphere', 'properties': {'typeSphere': {'type': 'string', 'title': 'type'}, 'centerSphere': {'type': 'string', 'title': 'point1', 'format': 'vector', 'description': 'Centre of sphere'}, 'radiusSphere': {'title': 'radius', 'type': 'number', 'description': 'Radius of sphere'}}}]}}}}, 'castellatedMeshControls': {'type': 'object', 'title': 'castellatedMeshControls', 'properties': {'locationInMesh': {'type': 'string', 'title': 'locationInMesh', 'format': 'vector', 'description': 'location vector inside the region to be meshed; vector must not coincide with a cell face either before or during refinement'}, 'maxLocalCells': {'type': 'number', 'title': 'maxLocalCells', 'description': 'max number of cells per processor during refinement.'}, 'maxGlobalCells': {'type': 'number', 'title': 'maxGlobalCells', 'description': 'overall cell limit during refinement'}, 'minRefinementCells': {'type': 'number', 'title': 'minRefinementCells', 'description': 'if minRefinementCells bigger/equal than number of cells to be refined, surface refinement stops'}, 'nCellsBetweenLevels': {'type': 'number', 'title': 'nCellsBetweenLevels', 'description': 'number of buffer layers of cells between successive levels of refinement'}, 'resolveFeatureAngle': {'type': 'number', 'title': 'resolveFeatureAngle', 'description': 'applies maximum level of refinement to cells that can see intersections whose angle exceeds resolveFeatureAngle'}, 'features': {'type': 'array', 'titles': 'features', 'items': {'type': 'object', 'description': 'list of features for refinement', 'properties': {'file': {'type': 'string', 'title': 'file'}, 'levels': {'type': 'string', 'title': 'levels'}}}}, 'refinementSurfaces': {'type': 'array', 'title': 'refinementSurfaces', 'items': {'type': 'object', 'properties': {'SurfaceName': {'type': 'string', 'title': 'Name of Surface'}, 'SurfaceProperties': {'type': 'object', 'properties': {'level': {'type': 'string', 'title': 'level'}, 'patchInfo': {'type': 'object', 'title': 'patchInfo', 'properties': {'type': {'type': 'string'}}}, 'regions': {'type': 'array', 'title': 'regions', 'items': {'type': 'object', 'properties': {'regionName': {'type': 'string', 'title': 'Name of region'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}}, 'refinementRegions': {'type': 'array', 'title': 'refinementRegions', 'items': {'type': 'object', 'properties': {'RegionName': {'type': 'string', 'title': 'Name of Region'}, 'RegionProperties': {'type': 'object', 'properties': {'mode': {'type': 'string', 'title': 'mode'}, 'levels': {'type': 'string', 'title': 'levels'}}}}}}}}, 'snapControls': {'type': 'object', 'title': 'snapControls', 'properties': {'nSmoothPatch': {'type': 'integer', 'title': 'nSmoothPatch', 'description': 'Number of smoothing iterations along the surface'}, 'nSmoothInternal': {'type': 'integer', 'title': 'nSmoothInternal', 'description': 'Number of iterations for internal smoothing to reduce non-orthogonality at the face of refinement (effectively making the faces non-planar).'}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'Multiplied by local cell-edge length specifies region along the surface within which the points are attracted by the surface.'}, 'nSolveIter': {'type': 'integer', 'title': 'nSolveIter', 'description': 'Number of mesh displacement iterations'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'Number of relaxation iterations during the snapping'}, 'nFeatureSnapIter': {'type': 'integer', 'title': 'nFeatureSnapIter', 'description': 'Number of relaxation iterations used for snapping onto the features'}, 'implicitFeatureSnap': {'type': 'boolean', 'title': 'implicitFeatureSnap', 'description': 'Switch turning on the implicit feature specification'}, 'explicitFeatureSnap': {'type': 'boolean', 'title': 'explicitFeatureSnap', 'description': 'Snap mesh onto the feature lines defined in eMesh file.'}, 'multiRegionFeatureSnap': {'type': 'boolean', 'title': 'multiRegionFeatureSnap', 'description': 'When using explicitFeatureSnap and this switch is on, features between multiple surfaces will be captured. This is useful for multi-region meshing where the internal mesh must conform the region geometrical boundaries'}}}, 'layers': {'type': 'array', 'title': 'layers', 'items': {'type': 'object', 'properties': {'name': {'type': 'string', 'title': 'Surface Name'}, 'layerProperties': {'type': 'object', 'properties': {'nSurfaceLayers': {'type': 'integer', 'title': 'nSurfaceLayers'}}}}}}, 'addLayersControls': {'type': 'object', 'title': 'addLayersControls', 'properties': {'relativeSizes': {'type': 'boolean', 'title': 'relativeSizes'}, 'expansionRatio': {'type': 'number', 'title': 'expansionRatio', 'description': 'expansion factor for layer mesh, increase in size from one layer to the next.'}, 'finalLayerThickness': {'type': 'number', 'title': 'finalLayerThickness', 'description': 'thickness of layer furthest from the wall, usually in combination with relative sizes according to the relativeSizes entry.'}, 'firstLayerThickness': {'type': 'number', 'title': 'firstLayerThickness', 'description': 'thickness of layer nearest the wall, usually in combination with absolute sizes according to the relativeSizes entry.'}, 'thickness': {'type': 'number', 'title': 'thickness', 'description': 'total thickness of all layers of cells, usually in combination with absolute sizes according to the relativeSizes entry'}, 'minThickness': {'type': 'number', 'title': 'minThickness', 'description': 'minimum thickness of cell layer, either relative or absolute'}, 'nGrow': {'type': 'integer', 'title': 'nGrow', 'description': 'number of layers of connected faces that are not grown if points do not get extruded'}, 'featureAngle': {'type': 'number', 'title': 'featureAngle', 'description': 'angle above which surface is not extruded'}, 'slipFeatureAngle': {'type': 'number', 'title': 'slipFeatureAngle', 'description': 'At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle'}, 'nRelaxIter': {'type': 'integer', 'title': 'nRelaxIter', 'description': 'maximum number of snapping relaxation iterations'}, 'nSmoothSurfaceNormals': {'type': 'integer', 'title': 'nSmoothSurfaceNormals', 'description': 'number of smoothing iterations of surface normals'}, 'nSmoothNormals': {'type': 'integer', 'title': 'nSmoothNormals', 'description': 'number of smoothing iterations of interior mesh movement direction'}, 'nSmoothThickness': {'type': 'integer', 'title': 'nSmoothThickness', 'description': 'smooth layer thickness over surface patches'}, 'maxFaceThicknessRatio': {'type': 'number', 'title': 'maxFaceThicknessRatio', 'description': 'stop layer growth on highly warped cells'}, 'maxThicknessToMedialRatio': {'type': 'number', 'title': 'maxThicknessToMedialRatio', 'description': 'reduce layer growth where ratio thickness to medial distance is large'}, 'minMedianAxisAngle': {'type': 'number', 'title': 'minMedianAxisAngle', 'description': 'angle used to pick up medial axis points'}, 'nBufferCellsNoExtrude': {'type': 'integer', 'title': 'nBufferCellsNoExtrude', 'description': 'create buffer region for new layer terminations'}, 'nLayerIter': {'type': 'integer', 'title': 'nLayerIter', 'description': 'overall max number of layer addition iterations'}, 'nRelaxedIter': {'type': 'integer', 'title': 'nRelaxedIter', 'description': 'max number of iterations after which the controls in the relaxed sub dictionary of meshQuality are used'}}}, 'meshQualityControls': {'type': 'object', 'title': 'meshQualityControls', 'properties': {'maxNonOrtho': {'type': 'number', 'title': 'maxNonOrtho', 'description': 'maximum non-orthogonality allowed'}, 'maxBoundarySkewness': {'type': 'number', 'title': 'maxBoundarySkewness', 'description': 'max boundary face skewness allowed'}, 'maxInternalSkewness': {'type': 'number', 'title': 'maxInternalSkewness', 'description': 'max internal face skewness allowed'}, 'maxConcave': {'type': 'number', 'title': 'maxConcave', 'description': 'max concaveness allowed'}, 'minFlatness': {'type': 'number', 'title': 'minFlatness', 'description': 'ratio of minimum projected area to actual area'}, 'minTetQuality': {'type': 'number', 'title': 'minTetQuality', 'description': 'minimum quality of tetrahedral cells from cell decomposition'}, 'minVol': {'type': 'number', 'title': 'minVol', 'description': 'minimum cell pyramid volume'}, 'minArea': {'type': 'number', 'title': 'minArea', 'default': -1, 'description': 'minimum face area'}, 'minTwist': {'type': 'number', 'title': 'minTwist', 'description': 'minimum face twist'}, 'minDeterminant': {'type': 'number', 'title': 'minDeterminant', 'description': 'minimum normalised cell determinant'}, 'minFaceWeight': {'type': 'number', 'title': 'minFaceWeight'}, 'minVolRatio': {'type': 'number', 'title': 'minVolRatio'}, 'minTriangleTwist': {'type': 'number', 'title': 'minTriangleTwist'}, 'nSmoothScale': {'type': 'integer', 'title': 'nSmoothScale', 'description': 'number of error distribution iterations'}, 'errorReduction': {'type': 'number', 'title': 'errorReduction', 'description': 'amount to scale back displacement at error points'}, 'relaxed': {'type': 'object', 'title': 'relaxed', 'description': 'sub-dictionary that can include modified values for the above keyword entries to be used when nRelaxedIter is exceeded in the layer addition process', 'additionalProperties': {'type': 'string'}}}}, 'writeFlags': {'type': 'array', 'items': {'type': 'string'}}}}, 'uiSchema': {}, 'formData': {'castellatedMesh': True, 'snap': False, 'addLayers': True, 'geometry': [{'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'buildings'}, 'nameSO': 'buildings.stl'}, {'geometry objects': {'typeTSM': 'triSurfaceMesh', 'nameTSM': 'topo'}, 'nameSO': 'topo.stl'}, {'geometry objects': {'typeBox': 'searchableBox', 'minBox': '(-250 -250   0)', 'maxBox': '(250 250  10)'}, 'nameSO': 'refinementBox'}], 'castellatedMeshControls': {'nCellsBetweenLevels': 2, 'maxLocalCells': 200000000, 'maxGlobalCells': 200000000, 'features': [{'file': 'topo.eMesh', 'levels': '((3 2) (20 1))'}, {'file': 'buildings.eMesh', 'levels': '((3 2) (20 1))'}], 'refinementSurfaces': [{'SurfaceName': 'buildings', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}, {'SurfaceName': 'topo', 'SurfaceProperties': {'level': '(2 1)', 'patchInfo': {'type': 'wall'}}}], 'refinementRegions': [{'RegionProperties': {'mode': 'inside', 'levels': '((1E15 1))'}, 'RegionName': 'refinementBox'}], 'locationInMesh': '(207000 738000 635)'}, 'snapControls': {'explicitFeatureSnap': True, 'implicitFeatureSnap': False}, 'layers': [{'name': 'buildings', 'layerProperties': {'nSurfaceLayers': 1}}], 'addLayersControls': {'relativeSizes': True, 'expansionRatio': 1, 'finalLayerThickness': 0.3, 'minThickness': 0.1, 'nGrow': 0, 'featureAngle': 60, 'slipFeatureAngle': 30, 'nRelaxIter': 3, 'nSmoothSurfaceNormals': 1, 'nSmoothNormals': 3, 'nSmoothThickness': 10, 'maxFaceThicknessRatio': 0.5, 'maxThicknessToMedialRatio': 0.3, 'minMedianAxisAngle': 90, 'nBufferCellsNoExtrude': 0, 'nLayerIter': 50}, 'meshQualityControls': {}, 'writeFlags': ['scalarLevels', 'layerSets', 'layerFields'], 'mergeTolerance': 1e-06}}}, 'ControlDict': {'typeExecution': 'controlDict', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'title': '', 'description': '', 'type': 'object', 'properties': {'application': {'type': 'string', 'title': 'application'}, 'startFrom': {'type': 'string', 'enum': ['firstTime', 'startTime', 'latestTime'], 'description': 'Controls the start time of the simulation.'}, 'startTime': {'title': 'startTime', 'type': 'number', 'description': 'Start time for the simulation with startFrom startTime'}, 'stopAt': {'type': 'string', 'enum': ['endTime', 'writeNow', 'noWriteNow', 'nextwrite'], 'description': 'Controls the end time of the simulation.'}, 'endTime': {'title': 'endTime', 'type': 'number', 'description': 'End time for the simulation when stopAt endTime; is specified.'}, 'deltaT': {'title': 'deltaT', 'type': 'number', 'description': 'Time step of the simulation.'}, 'writeControl': {'type': 'string', 'enum': ['timeStep', 'runTime', 'adjustableRunTime', 'cpuTime', 'clockTime'], 'description': 'Controls the timing of write output to file.'}, 'writeInterval': {'title': 'writeInterval', 'type': 'integer', 'description': 'Scalar used in conjunction with writeControl described above.'}, 'purgeWrite': {'title': 'purgeWrite', 'type': 'integer', 'description': 'Integer representing a limit on the number of time directories that are stored by overwriting time directories on a cyclic basis.'}, 'writeFormat': {'type': 'string', 'enum': ['ascii', 'binary'], 'description': 'Specifies the format of the data files.'}, 'writePrecision': {'title': 'writePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with writeFormat described above.'}, 'writeCompression': {'type': 'boolean', 'title': 'writeCompression', 'description': 'Switch to specify whether files are compressed with gzip'}, 'timeFormat': {'type': 'string', 'enum': ['fixed', 'scientific', 'general'], 'description': 'Controls the timing of write output to file.'}, 'timePrecision': {'title': 'timePrecision', 'type': 'integer', 'description': 'Integer used in conjunction with timeFormat described above'}, 'runTimeModifiable': {'type': 'boolean', 'title': 'runTimeModifiable', 'description': 'Switch for whether dictionaries, e.g. controlDict, are re-read during a simulation at the beginning of each time step, allowing the user to modify parameters during a simulation.'}, 'graphFormat': {'type': 'string', 'enum': ['no graph', 'raw', 'gnuplot', 'xmgr', 'jplot'], 'description': 'Format for graph data written by an application.'}, 'adjustTimeStep': {'type': 'boolean', 'title': 'adjustTimeStep', 'description': 'Switch used by some solvers to adjust the time step during the simulation, usually according to maxCo.'}, 'maxCo': {'title': 'maxCo', 'type': 'number', 'description': 'Maximum Courant number.'}, 'interpolate': {'type': 'boolean', 'title': 'interpolate'}, 'libs': {'type': 'array', 'title': 'libs', 'items': {'type': 'string', 'description': 'List of additional libraries (on $LD_LIBRARY_PATH) to be loaded at run-time'}}, 'functions': {'type': 'array', 'title': 'functions', 'items': {'type': 'string', 'description': 'Dictionary of functions, e.g.  probes to be loaded at run-time'}}}}, 'uiSchema': {'listOfStrings': {'items': {'ui:emptyValue': ''}}, 'functions': {'items': {'ui:emptyValue': ''}}}, 'formData': {'application': 'simpleFOAM', 'startFrom': 'startTime', 'startTime': 0, 'stopAt': 'endTime', 'endTime': 1000, 'deltaT': 1, 'writeControl': 'timeStep', 'writeInterval': 100, 'purgeWrite': 0, 'writeFormat': 'ascii', 'writePrecision': 7, 'writeCompression': False, 'timeFormat': 'general', 'timePrecision': 6, 'runTimeModifiable': True, 'interpolate': True, 'functions': ['probes.txt']}}}, 'fvSchemes': {'typeExecution': 'fvSchemes', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'ddtSchemes': {'type': 'object', 'title': 'timeScheme', 'properties': {'default': {'type': 'string', 'enum': ['steadyState', 'Euler', 'backward', 'CrankNicolson', 'localEuler'], 'description': 'The discretisation schemes for each term can be selected from those listed below.'}}}, 'gradSchemes': {'type': 'object', 'title': 'gradSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'enum': ['Gauss linear', 'leastSquares', 'Gauss'], 'description': 'The discretisation scheme'}, 'grad(U)': {'type': 'string', 'title': 'grad(U)', 'description': 'discretisation of velocity gradient terms is overridden to improve boundedness and stability'}, 'grad(k)': {'type': 'string', 'title': 'grad(k)', 'description': 'discretisation of k gradient terms is overridden to improve boundedness and stability'}, 'grad(epsilon)': {'type': 'string', 'title': 'grad(epsilon)', 'description': 'discretisation of epsilon gradient terms is overridden to improve boundedness and stability'}}}, 'divSchemes': {'type': 'object', 'title': 'divSchemes', 'properties': {'default': {'type': 'string', 'title': 'default', 'description': 'contains divergence terms.'}, 'div(phi,U)': {'type': 'string', 'title': 'div(phi,U)'}, 'div(phi,k)': {'type': 'string', 'title': 'div(phi,k)'}, 'div(phi,epsilon)': {'type': 'string', 'title': 'div(phi,epsilon)'}, 'div(phi,e)': {'type': 'string', 'title': 'div(phi,e)'}, 'div(phi,omega)': {'type': 'string', 'title': 'div(phi,omega)'}, 'more divSchemes properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}, 'laplacianSchemes': {'type': 'object', 'title': 'laplacianSchemes', 'description': 'Laplacian terms.', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'interpolationSchemes': {'type': 'object', 'title': 'interpolationSchemes', 'description': 'terms that are interpolations of values typically from cell centres to face centres', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'snGradSchemes': {'type': 'object', 'title': 'snGradSchemes', 'description': 'contains surface normal gradient terms', 'properties': {'default': {'type': 'string', 'title': 'default'}}}, 'wallDist': {'type': 'object', 'title': 'wallDist', 'properties': {'method': {'type': 'string', 'title': 'method'}}}, 'fluxRequired': {'type': 'object', 'title': 'fluxRequired', 'properties': {'default': {'type': 'string', 'title': 'default'}}}}}, 'uiSchema': {}, 'formData': {'ddtSchemes': {'default': 'steadyState'}, 'gradSchemes': {'default': 'Gauss linear', 'grad(U)': 'cellLimited Gauss linear 1', 'grad(k)': 'cellLimited Gauss linear 1', 'grad(epsilon)': 'cellLimited Gauss linear 1'}, 'divSchemes': {'more divSchemes properties': {'div((nuEff*dev2(T(grad(U)))))': 'Gauss linear'}, 'default': 'none', 'div(phi,U)': 'bounded Gauss upwind', 'div(phi,k)': 'bounded Gauss upwind', 'div(phi,epsilon)': 'bounded Gauss upwind', 'div(phi,omega)': 'bounded Gauss upwind'}, 'laplacianSchemes': {'default': 'Gauss linear corrected'}, 'interpolationSchemes': {'default': 'linear'}, 'snGradSchemes': {'default': 'corrected'}, 'wallDist': {'method': 'meshWave'}}}}, 'fvSolution': {'typeExecution': 'fvSolution', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'solvers': {'type': 'array', 'title': 'solvers', 'items': {'type': 'object', 'properties': {'parameterName': {'type': 'string', 'title': 'parametr name', 'description': 'name of the parameter - P|U|k|omega|epsilon and etc.'}, 'parameterProperties': {'type': 'object', 'properties': {'solver': {'type': 'string', 'title': 'solver', 'enum': ['PCG', 'PCG/PBiCGStab', 'PCG/PBiCG', 'smoothSolver', 'GAMG', 'diagonal']}, 'preconditioner': {'type': 'string', 'title': 'preconditioner', 'enum': ['none', 'DIC', 'DILU', 'FDIC', 'diagonal', 'GAMG']}, 'smoother': {'type': 'string', 'title': 'smoother', 'enum': ['none', 'GaussSeidel', 'symGaussSeidel', 'DIC', 'DILU', 'DICGaussSeidel']}, 'tolerance': {'type': 'number', 'title': 'tolerance', 'description': 'the solver tolerance'}, 'relTol': {'type': 'number', 'title': 'relTol', 'description': 'the solver relative tolerance'}, 'GAMGproperties': {'type': 'array', 'title': 'GAMG properties', 'items': {'type': 'object', 'properties': {'cacheAgglomeration': {'type': 'boolean', 'title': 'cacheAgglomeration', 'description': 'switch specifying caching of the agglomeration strategy'}, 'agglomerator': {'type': 'string', 'title': 'agglomerator'}, 'nCellsInCoarsestLevel': {'type': 'integer', 'title': 'nCellsInCoarsestLevel', 'description': 'approximate mesh size at the most coarse level in terms of the number of cells'}, 'directSolveCoarset': {'type': 'boolean', 'title': 'directSolveCoarset', 'description': 'use a direct solver at the coarsest level'}, 'mergeLevels': {'type': 'integer', 'title': 'mergeLevels', 'description': 'controls the speed at which coarsening or refinement is performed'}}}}, 'SmoothProperties': {'type': 'array', 'title': 'Smooth Properties', 'items': {'type': 'object', 'properties': {'nPreSweeps': {'type': 'integer', 'title': 'nPreSweeps', 'description': 'number of sweeps as the algorithm is coarsening'}, 'preSweepsLevelMultiplier': {'type': 'integer', 'title': 'preSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each coarsening level'}, 'maxPreSweeps': {'type': 'integer', 'title': 'maxPreSweeps', 'description': 'maximum number of sweeps as the algorithm is coarsening'}, 'nPostSweeps': {'type': 'integer', 'title': 'nPostSweeps', 'description': 'number of sweeps as the algorithm is refining'}, 'postSweepsLevelMultiplier': {'type': 'integer', 'title': 'postSweepsLevelMultiplier', 'description': 'multiplier for the the number of sweeps between each refinement level'}, 'maxPostSweeps': {'type': 'integer', 'title': 'maxPostSweeps', 'description': 'maximum number of sweeps as the algorithm is refining'}, 'nFinestSweeps': {'type': 'integer', 'title': 'nFinestSweeps', 'description': 'number of sweeps at finest level'}}}}, 'more properties': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}}, 'algorithms': {'type': 'array', 'title': 'PISO, SIMPLE or PIMPLE algorithms', 'items': {'type': 'object', 'anyOf': [{'type': 'object', 'title': 'PISO', 'description': 'pressure-implicit split-operator', 'properties': {'nCorrectorsPISO': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPISO': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorPISO': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPISO': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePISO': {'type': 'number', 'title': 'pRefValue'}}}, {'type': 'object', 'title': 'SIMPLE', 'description': 'semi-implicit method for pressure-linked equations', 'properties': {'SIMPLEName': {'type': 'string', 'title': 'name', 'default': 'SIMPLE'}, 'SIMPLEproperties': {'type': 'object', 'title': 'SIMPLEproperties', 'properties': {'residualControl': {'type': 'object', 'additionalProperties': {'type': 'number'}}, 'nNonOrthogonalCorrectorsSIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'momentumPredictorSIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellSIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValueSIMPLE': {'type': 'number', 'title': 'pRefValue'}}}}}, {'type': 'object', 'title': 'PIMPLE', 'description': 'combined - PISO+SIMPLE', 'properties': {'nCorrectorsPIMPLE': {'type': 'integer', 'title': 'nCorrectors', 'description': 'sets the number of times the algorithm solves the pressure equation and momentum corrector in each step'}, 'nNonOrthogonalCorrectorsPIMPLE': {'type': 'number', 'title': 'nNonOrthogonalCorrectors', 'description': 'pecifies repeated solutions of the pressure equation, used to update the explicit non-orthogonal correction'}, 'nOuterCorrectorsPIMPLE': {'type': 'integer', 'title': 'nOuterCorrectors', 'description': 'it enables looping over the entire system of equations within on time step, representing the total number of times the system is solved'}, 'momentumPredictorPIMPLE': {'type': 'boolean', 'title': 'momentumPredictor', 'description': 'switch that controls solving of the momentum predictor'}, 'pRefCellPIMPLE': {'type': 'number', 'title': 'pRefCell'}, 'pRefValuePIMPLE': {'type': 'number', 'title': 'pRefValue'}}}]}}, 'potentialFlow': {'type': 'object', 'title': 'potentialFlow', 'properties': {'nNonOrthogonalCorrectors': {'type': 'number', 'title': 'nNonOrthogonalCorrectors'}}}, 'relaxationFactors': {'type': 'object', 'title': 'relaxationFactors', 'properties': {'fields': {'type': 'object', 'title': 'relaxationFactors-fields', 'additionalProperties': {'type': 'number'}}, 'equations': {'type': 'object', 'title': 'relaxationFactors-equations', 'additionalProperties': {'type': 'number'}}}}}}, 'uiSchema': {}, 'formData': {'solvers': [{'parameterProperties': {'GAMGproperties': [{'cacheAgglomeration': True, 'agglomerator': 'faceAreaPair', 'nCellsInCoarsestLevel': 10, 'mergeLevels': 1}], 'solver': 'GAMG', 'smoother': 'GaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': 'P'}, {'parameterProperties': {'more properties': {}, 'solver': 'smoothSolver', 'smoother': 'symGaussSeidel', 'tolerance': 1e-06, 'relTol': 0.1}, 'parameterName': '(U|k|omega|epsilon)'}], 'algorithms': [{'SIMPLEName': 'SIMPLE', 'SIMPLEproperties': {'residualControl': {'P': 0.0001, 'U': 0.0001, '(k|omega|epsilon)': 0.0001}, 'nNonOrthogonalCorrectorsSIMPLE': 5, 'pRefCellSIMPLE': 0, 'pRefValueSIMPLE': 0}}], 'potentialFlow': {'nNonOrthogonalCorrectors': 10}, 'relaxationFactors': {'fields': {'P': 0.3}, 'equations': {'U': 0.7, '(k|omega|epsilon).*': 0.7}}}}}, 'transportProperties': {'typeExecution': 'transportProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'transportModel': {'type': 'string', 'title': 'transportModel'}, 'nu': {'type': 'string', 'title': 'nu'}}}, 'uiSchema': {}, 'formData': {'transportModel': 'Newtonian', 'nu': '[0 2 -1 0 0 0 0] 1.5e-05'}}}, 'RASProperties': {'typeExecution': 'RASProperties', 'TypeFC': 'WebGuiNode', 'input_parameters': {'formData': '{WebGui.formData}'}, 'Properties': {}, 'WebGui': {'Schema': {'type': 'object', 'properties': {'simulationType': {'type': 'string', 'title': 'simulationType'}, 'RAS': {'type': 'object', 'title': 'RAS', 'properties': {'RASModel': {'type': 'string', 'title': 'RASModel', 'enum': ['LRR', 'LamBremhorstKE', 'LaunderSharmaKE', 'LienCubicKE', 'LienLeschziner', 'RNGkEpsilon', 'SSG', 'ShihQuadraticKE', 'SpalartAllmaras', 'kEpsilon', 'kOmega', 'kOmegaSST', 'kOmegaSSTLM', 'kOmegaSSTSAS', 'kkLOmega', 'qZeta', 'realizableKE', 'v2f'], 'description': 'name of RAS turbulence model.'}, 'turbulence': {'type': 'boolean', 'title': 'turbulence', 'description': 'switch to turn the solving of turbulence modelling on/off'}, 'printCoeffs': {'type': 'boolean', 'title': 'printCoeffs', 'description': 'switch to print model coeffs to terminal at simulation start up.'}, 'RASModelCoeffs': {'type': 'object', 'additionalProperties': {'type': 'string'}}}}}}, 'uiSchema': {}, 'formData': {'simulationType': 'RAS', 'RAS': {'RASModel': 'kEpsilon', 'turbulence': True, 'printCoeffs': True}}}}, 'finalnode_xx': {'name': 'finalnode_xx', 'typeExecution': 'parameters', 'requires': ['CopyDirectory', 'RunPythonScript', 'RunOsCommand', 'BC', 'SnappyHexMesh', 'ControlDict', 'fvSchemes', 'fvSolution', 'transportProperties', 'RASProperties'], 'input_parameters': {}}}}}['workflow']

    def output(self):
        return luigi.LocalTarget("outputsOriginal/finalnode_xx_0.json")

    def requires(self):
        return dict(
                       SnappyHexMesh=SnappyHexMesh_0(),
                       RASProperties=RASProperties_0(),
                       fvSolution=fvSolution_0(),
                       RunPythonScript=RunPythonScript_0(),
                       CopyDirectory=CopyDirectory_0(),
                       transportProperties=transportProperties_0(),
                       RunOsCommand=RunOsCommand_0(),
                       BC=BC_0(),
                       fvSchemes=fvSchemes_0(),
                       ControlDict=ControlDict_0()
                   )

    def run(self):
        target = self.output()
        target.makedirs()
        
        task_executer_mapping = {}
        
        parameters_from_required = self.get_all_required_outputs()        
        params = dict(parameters_from_required)
        params['parameters'] = {}
        params['WebGUI']     = {}
        params['Properties'] = {}
        params['WebGui']     = {}
        
        executer_parameters = self.build_executer_parameters(task_executer_mapping, params)
        executer_parameters['WD_path']='/home/noga/Noga/FreeCad/github/Hermes/master/Hermes/examples/simpleFOAM'
                    
        from hermes.Resources.executers.generalExecuter import parameterExecuter  
        output =  parameterExecuter(self._taskJSON).run(**executer_parameters)
        
        params['input_parameters'] = executer_parameters 
        params['output'] = output        
        
        out_params = params
        with open(self.output().fn,"w") as outfile:
            json.dump(out_params,outfile)
